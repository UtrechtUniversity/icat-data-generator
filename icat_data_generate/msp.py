"""Code for computing minimum sum products.
"""

from math import ceil, sqrt


def compute_msp(a_available, b_available, c_needed):
    """The iCAT database has a number of table that map entity to another.
       For example, R_OBJT_METAMAP maps objects such as collections to
       metadata entries.

       Data for these mapping tables is generated by taking a subset of
       the Cartesian product of the mapped entities. Since the number
       of mapping table entries is often (substantially) less than the
       product of the number of mapped table entries, we don't have to
       compute the complete Cartesian product. In that case we would
       choose a number of entries of each mapped table that minimizes
       the sum of number of mapped entries.

       For example, consider a mapping table C which maps entries of table
       A to entries of table B. Let's say we need a million entries in
       table C, and we have a million entries in both table A and B.
       If we compute the Cartesian product of one million entries of
       table A and one entry in table B, we would need to keep
       1,000,000 + 1 = 1,000,001 entries in memory. However, if we
       use 1,000 entries of table A and 1,000 entries in table B, we
       need to keep only 1,000 + 1,000 = 2,000 entries in memory.

       This function computes (approximate) numbers of A and B so that
       A + B is minimized, while A * B >= C.

       :param a_available: number of entries available in mapped table A
       :param b_available: number of entries available in mapped table B
       :param c_needed: number of entries needed for in mapped table C
       :returns: two-tuple of number of entries of table A and B to create
           Cartesian product of sufficient size to create needed number of
           entries in table C
       :raises ValueError: number of entries in table A and B is too low
    """
    if a_available * b_available < c_needed:
        raise ValueError(
            "Mapped table size too low to compute minimum sum product.")
    elif a_available >= sqrt(c_needed) and b_available >= sqrt(c_needed):
        return (ceil(sqrt(c_needed)), ceil(sqrt(c_needed)))
    elif a_available < b_available:
        return (a_available, ceil(c_needed/a_available))
    else:
        return (ceil(c_needed/b_available), b_available)
